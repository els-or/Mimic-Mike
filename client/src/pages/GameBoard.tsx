
//Libraries
import { useApolloClient } from "@apollo/client";
import { useEffect, useState } from "react";
import { useNavigate } from "react-router-dom";

//Utility files
import { createGameSession, updateUserScore, getUser, deleteGameSession } from "../utils/gameDatabaseHelpers";
import { boardOneButtons } from "../utils/buttonArray";
import { getRandomInt, playSound } from "../utils/gameLogicHelpers";


//Interfaces
import { GameSession } from "../interfaces/GameSession";

//Components
import GameOverScreen from "../components/Game/GameOverScreen";


/* **********TODOS**********
  - clean up code
  - try to find uniform test sounds 
  - consider changing conditional checks with buttons to use button.id for comparison instead of button.text
  - update the round number before the sequence plays so the user can see what round they are on.
  -add loading spinner
  -make sure game session is terminated if user leaves the page via a navbar button
  -add check to see if the user is logged in before allowing them to play the game
 */


import "../styles/GameBoard.css";


const GameBoard = () => {
 const navigate = useNavigate();

//#region State Variables

  //State to store and track the game session
  const [gameSession, setGameSession] = useState<GameSession | null>(null);

  //State to store the game's score (**NOTE: this is not the same as the score that is a part of createGameSession**)
  const [score, setScore] = useState(0); 

  //State to hold the users current high score for display upon game over
  const [highScoreMessage, setHighScoreMessage] = useState('');

  //State to track if the game has started.

  const [gameStarted, setGameStarted] = useState(false);

  // Indicates if the game has ended
  const [gameOver, setGameOver] = useState(false);

  // Stores the sequence of buttons generated by the computer
  const [gameSequence, setGameSequence] = useState<string[]>([]);

  // Stores the sequence of buttons pressed by the user
  const [userSequence, setUserSequence] = useState<string[]>([]);

  // Keeps track of the current round number
  const [round, setRound] = useState<number>(0);

  // Controls whether user input is allowed
  const [inputLocked, setInputLocked] = useState<boolean>(false);

  // Indicates if the game is in a loading state
  const [isLoading, setIsLoading] = useState<boolean>(false);

  // Tracks which button is currently activated/highlighted
  const [activeButton, setActiveButton] = useState<string | null>(null);

//#endregion State Variables

//#region Create Game Session

  const client = useApolloClient();
 
  useEffect(() => {
    console.log("---------------------------");
    console.log("CLIENT USE EFFECT TRIGGERED");
    console.log("---------------------------\n");
    //TODO: make sure generateSession is used
    const generateSession = async () => {
      const session = await createGameSession(client);
      if(session){
        console.log('New game session:', session);
        //Store the session in state
        setGameSession(session);
      }else{
        console.error("Failed to create game session.");
        //TODO: Handle the failure case (e.g., show an error message or retry)
      }
    };

    if(!gameSession){
      //!!! WARNING: This could loop repeatedly if it continues to fail when communicating with the DB
      //TODO: Improve this so it will stop if it fails to get the data too many times
      generateSession();
    }
    
    startOrResetGame();
  },[client, gameSession]);
  
//#endregion Create Game Session

//#region Game Start/Reset Functions
  const startOrResetGame = () => {
    console.log("---------------------");
    console.log("running startOrResetGame");
    console.log("---------------------\n");
    try{
        setIsLoading(true);
        setGameOver(false);
        setGameSequence([]);
        setUserSequence([]);
        setScore(0);
        setRound(0);
    
        setInputLocked(false);
    
        // Simulate a short delay to ensure all states are reset before proceeding
        setTimeout(() => {
          setIsLoading(false); // Mark loading as complete
          //Important: Do this last so the game UI sees a fully initialized state
          setGameStarted(true);
        }, 1000); // Adjust the delay as needed
  
    }catch(error){
      console.error("Unable to create game session: ", error);
      //TODO: make an error modal??
      //TODO: add something here to offer a way to retry creating a game session
    }

  };

  // Initialize game when ready
  useEffect(() => {
    if (!isLoading && gameStarted) {
      setTimeout(() => {
          playSequence();
      }, 2000); 
      
    }
  }, [isLoading, gameStarted]);

//#endregion Game Start/Reset Functions

//#region Score Functions
//this updates the user score as well by calling a function that uses the UPDATE_USER mutation
const getHighScore= async(): Promise<boolean | null > => {
  
  let newHighScore = false;

  if(!gameSession){
      throw new Error ("Unable to find user");
  }
  try{
      //this calls a helper method that uses the GET_ME query
      const currentUser = await getUser(client);

      if(!currentUser){
          throw new Error("Unable to find user");
      }

    const oldHighScore = currentUser.highScore;

    //Update the user with the current score from the game session (if it exceeds the user's high score)
    //Pass the entire game session
    const updatedUser = await updateUserScore(client, gameSession, score); 
    console.log("UPDATED USER = ", updatedUser)

    if (updatedUser) {
      console.log("oldHighScore ========== ", oldHighScore);
      console.log("updatedUser.highScore ====== ", updatedUser.highScore);

      // If the user's high score has increased, display a new high score message
      if (updatedUser.highScore > oldHighScore) {
          newHighScore = true;
      } 
      else{
          newHighScore = false;
      }
    }

  return newHighScore;

  }catch(error){
    console.error('Error handling game over:', error);
    return null;
  }
}
//#endreigon High Score Functions

//#region Game Over Functions
  //!!!! IMPORTANT NOTE: handleGameOver is called when the user fails a check inside the handlePlayerInput function
  const handleGameOver = async() => {
    setGameOver(true);
    //!!!This updates the user
    const newHighScore = await getHighScore(); // Await the result from getHighScore

    // Update the high score message if there is a new high score
    if (newHighScore) {
      setHighScoreMessage("New High Score!"); // Update with the message
    } 
  };
      
  const handlePlayAgain = async () => {
    console.log("Playing again");
  
    if (gameSession) {
      try {
        const result = await deleteGameSession(client, gameSession._id);
        if (result) {
          console.log("Previous game session deleted.");
        } else {
          console.warn("Previous game session deletion returned null.");
        }
      } catch (error) {
        console.error("Error deleting previous game session:", error);
      }
    }
  
    try {
      const session = await createGameSession(client);
      if (session) {
        setGameSession(session);
        console.log("New game session started:", session);
      } else {
        console.error("Failed to create new game session.");
      }
    } catch (error) {
      console.error("Error creating new game session:", error);
    }
  };


  const handleQuitGame = async () => {
    console.log("Game over, returning to home page");
  
    if (gameSession) {
      try {
        const result = await deleteGameSession(client, gameSession._id);
        if (result) {
          console.log("Game session deleted successfully.");
        } else {
          console.warn("Game session deletion returned null.");
        }
      } catch (error) {
        console.error("Error deleting game session:", error);
      }
    }
  
    navigate("/");
  };
//#endregion Game Over Functions

//#region Play Sequence
  // CPU game sequence logic
  const playSequence = () => {
    const randomInt = getRandomInt(1, 4);
    const nextButton = boardOneButtons.find((b) => b.id === randomInt);
    if (!nextButton) {
      console.error("Invalid button");
      return;
    }

    const newSequence = [...gameSequence, nextButton.id.toString()];
    setGameSequence(newSequence);
    setInputLocked(true);
    setRound((prev) => prev + 1);

    newSequence.forEach((buttonId, index) => {
      const button = boardOneButtons.find((b) => b.id.toString() === buttonId);
      if (!button) return;

      const onTime = 1000 * index;

      // Light up the button and play the sound
      setTimeout(() => {
        playSound(button.sound);
        setActiveButton(button.text);
      }, onTime);

      // Turn off the button
      setTimeout(() => {
        setActiveButton(null);
      }, onTime + 700);
    });

    // Re-enable player input after sequence
    const totalTime = newSequence.length * 1000;
    setTimeout(() => {
      setInputLocked(false);
      setUserSequence([]);
    }, totalTime + 100);
  };
//#endregion Play Sequence

//#region Player Input
  // Player input handler
  const handlePlayerInput = (buttonId: string) => {
    if (inputLocked || userSequence.length >= gameSequence.length) {
      return;
    }

    const button = boardOneButtons.find((b) => b.id.toString() === buttonId);
    if (!button) {
      console.error("Button not found");
      return;
    }

    const updatedUserSequence = [...userSequence, button.id.toString()];
    setUserSequence(updatedUserSequence);

    const currentIndex = updatedUserSequence.length - 1;
    const isCorrect =
      updatedUserSequence[currentIndex] === gameSequence[currentIndex];

    // Show feedback
    playSound(button.sound);
    setActiveButton(button.text);
    setTimeout(() => setActiveButton(null), 400);

    if (!isCorrect) {
      setInputLocked(true);
      setTimeout(() => {
        handleGameOver();
      }, 2000); //update this to reflect the sound playback length

      return;
    }

    // If round complete
    if (updatedUserSequence.length === gameSequence.length) {
      setTimeout(() => {
        setScore((prev) => prev + 1);
        setUserSequence([]);
        playSequence();
      }, 1000);
    }
  };
//#endregion Player Input

//#region Return TSX
  return (
    <>
      <div className="mimic-mike-home"></div>
        <div className="content-wrapper">
          {gameOver && (
            <GameOverScreen
              score={score}
              highScoreMessage={highScoreMessage} 
              onPlayAgain={handlePlayAgain}
              onQuit={handleQuitGame}
            />
          )}

          {gameStarted ? (
            <div className="game-container">
              <div className="game-header">
                <h1>Round {round}</h1>
                <p className="game-score">Score: {score}</p>
              </div>

              <div className="simon-container">
                {boardOneButtons.map((button) => (
                  <div
                    key={button.id}
                    className={`simon-button simon-${button.text.toLowerCase()} ${
                      activeButton === button.text ? "active" : ""
                    }`}
                    onClick={() => handlePlayerInput(button.id.toString())}
                    style={{
                      pointerEvents: inputLocked ? "none" : "auto",
                    }}
                  >
                      <div className="button-inner">{button.text}</div>
                  </div>
                ))}
                <div className="simon-center">
                    <div className="round-display">{round}</div>
                </div>
              </div>

              <div className="game-controls">
                  <button className="secondary-button" onClick={handleQuitGame}>
                    Quit Game
                  </button>
              </div>
          </div>
        ) : (
          <div className="home-container">
            <div className="title-animation">
              <h1>Mimic Mike</h1>
              <p className="tagline">Test your memory skills!</p>
            </div>

            <div className="game-info">
              <p>
                Watch and listen to the pattern sequence, then repeat it back in
                the correct order.
              </p>
              <p>How many rounds can you go?</p>
            </div>
        </div>
        )}
      </div>
    </>
  );
//#enregion Return TSX
};

export default GameBoard;
