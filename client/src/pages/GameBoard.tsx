//Libraries
import { useApolloClient } from "@apollo/client";
import { useRef, useEffect, useState } from "react";
import { useNavigate } from "react-router-dom";

//Utility files
import { createGameSession, updateUserScore, getUser, deleteGameSession } from "../utils/gameDatabaseHelpers";
import { boardOneButtons } from "../utils/buttonArray";
import { getRandomInt, playSound } from "../utils/gameLogicHelpers";

//Interfaces
import { GameSession } from "../interfaces/GameSession";

//Components
import GameOverScreen from "../components/Game/GameOverScreen";

import "../styles/GameBoard.css";


const GameBoard = () => {
  const navigate = useNavigate();

  //#region State Variables

    //Stores and track the game session
    const [gameSession, setGameSession] = useState<GameSession | null>(null);

    //Stores the game's score (**NOTE: this is not the same as the score that is a part of createGameSession**)
    const [score, setScore] = useState(0); 

    //Holds the users current high score for display upon game over
    const [highScoreMessage, setHighScoreMessage] = useState('');

    //Tracks if the game has started.
    const [gameStarted, setGameStarted] = useState(false);

    //Indicates if the game has ended
    const [gameOver, setGameOver] = useState(false);

    //Stores the sequence of buttons generated by the computer
    const [gameSequence, setGameSequence] = useState<string[]>([]);

    //Stores the sequence of buttons pressed by the user
    const [userSequence, setUserSequence] = useState<string[]>([]);

    //Keeps track of the current round number
    const [round, setRound] = useState<number>(0);

    //Controls whether user input is allowed
    const [inputLocked, setInputLocked] = useState<boolean>(false);

    //Indicates if the game is in a loading state
    const [isLoading, setIsLoading] = useState<boolean>(false);

    //Tracks which button is currently activated/highlighted
    const [activeButton, setActiveButton] = useState<string | null>(null);

    //Reference to track if playSequence already triggered
    const hasStartedRef = useRef(false); 

  //#endregion State Variables


  //#region Create Game Session

      const client = useApolloClient();
      
      //INITIAL GAME SESSION CREATION
      //This creates the game session when the component mounts
      useEffect(() => {
        const generateSession = async () => {
          const session = await createGameSession(client);
          if (session) {
            setGameSession(session);
          }else {
            console.error("Failed to create game session.");
          }
        };

        if (!gameSession) {
          generateSession();
        }
        setTimeout(() => {
          setIsLoading(false);
        }, 4000); //Simulate a delay for loading

      },[]);
      
      //SUBSEQUENT GAME SESSION CREATION
      useEffect(() => {
        if (gameSession) {
          startOrResetGame();
        }
      }, [gameSession]);

  //#endregion Create Game Session


  //#region Game Start/Reset Functions

    const startOrResetGame = () => {
      try {
          setIsLoading(true);
          setGameOver(false);
          setGameSequence([]);
          setUserSequence([]);
          setScore(0);
          setRound(0);
          setInputLocked(false);
          hasStartedRef.current = false; //<-- Reset the ref here!

          //Simulate a short delay to ensure all states are reset before proceeding
          setTimeout(() => {
            setIsLoading(false);
            //Important: Do this last so the game UI sees a fully initialized state
            setGameStarted(true);
          }, 1000);       
      }catch(error) {
        console.error("Unable to create game session: ", error);
      }
    };

    //Initialize game when ready
    useEffect(() => {
      if (!isLoading && gameStarted && !hasStartedRef.current) {    
        hasStartedRef.current = true; //Mark it so it doesn't run again
    
        setTimeout(() => {
          playSequence();
        }, 1000);
      }
    }, [isLoading, gameStarted]);

  //#endregion Game Start/Reset Functions


  //#region High Score Function

    //this updates the user score property as well by calling a function that uses the UPDATE_USER mutation
    const getHighScore= async(): Promise<boolean | null > => {
      
      let newHighScore = false;

      if (!gameSession) {
          throw new Error ("Unable to find user");
      }

      try {
          //this calls a helper method that uses the GET_ME query
          const currentUser = await getUser(client);

          if (!currentUser) {
              throw new Error("Unable to find user");
          }

          const oldHighScore = currentUser.highScore;

          //Update the user with the current score from the game session (if it exceeds the user's high score)
          //Pass the entire game session
          const updatedUser = await updateUserScore(client, gameSession, score); 

          if (updatedUser) {
            // If the user's high score has increased, display a new high score message
            if (updatedUser.highScore > oldHighScore) {
                newHighScore = true;
            } 
            else {
                newHighScore = false;
            }
          }

        return newHighScore;

      } catch (error) {
        console.error('Error handling game over:', error);
        return null;
      }
    }

  //#endreigon High Score Function


  //#region Game Over Functions

    //!!!! IMPORTANT NOTE: handleGameOver is called when the user fails a check inside the handlePlayerInput function
    const handleGameOver = async() => {
      setGameOver(true);

      //!!!This updates the user
      const newHighScore = await getHighScore(); // Await the result from getHighScore

      // Update the high score message if there is a new high score
      if (newHighScore) {
        setHighScoreMessage("New High Score!");
      } 
    };
        
    const handlePlayAgain = async () => {
      if (gameSession) {
        try {
          const result = await deleteGameSession(client, gameSession._id);

          if (result) {
            console.log("Previous game session deleted.");
          } else {
            console.warn("Previous game session deletion returned null.");
          }

        } catch (error) {
          console.error("Error deleting previous game session:", error);
        }
      }
    
      try {
        const session = await createGameSession(client);

        if (session) {
          setGameSession(session);
        } else {
          console.error("Failed to create new game session.");
        }

      } catch (error) {
        console.error("Error creating new game session:", error);
      }
    };


    const handleQuitGame = async () => {   
      if (gameSession) {
        try {
          const result = await deleteGameSession(client, gameSession._id);
          if (result) {
            console.log("Game session deleted successfully.");
          } else {
            console.warn("Game session deletion returned null.");
          }
        } catch (error) {
          console.error("Error deleting game session:", error);
        }
      }
    
      navigate("/");
    };

  //#endregion Game Over Functions

  //#region Play Sequence

    // CPU game sequence logic
    const playSequence = () => {
      const randomInt = getRandomInt(1, 4);
      const nextButton = boardOneButtons.find((b) => b.id === randomInt);
      if (!nextButton) {
        console.error("Invalid button");
        return;
      }

      const newSequence = [...gameSequence, nextButton.id.toString()];
      setGameSequence(newSequence);
      setInputLocked(true);

      setRound((prev) => prev + 1);

      newSequence.forEach((buttonId, index) => {
        const button = boardOneButtons.find((b) => b.id.toString() === buttonId);
        if (!button) return;

        const onTime = 1000 * index;

        //Light up the button and play the sound
        setTimeout(() => {
          playSound(button.sound);
          setActiveButton(button.text);
        }, onTime);

        //Turn off the button
        setTimeout(() => {
          setActiveButton(null);
        }, onTime + 700);
      });

      //Re-enable player input after sequence
      const totalTime = newSequence.length * 1000;
      setTimeout(() => {
        setInputLocked(false);
        setUserSequence([]);
      }, totalTime + 100);
    };

  //#endregion Play Sequence


  //#region Player Input

    const handlePlayerInput = (buttonId: string) => {
      if (inputLocked || userSequence.length >= gameSequence.length) {
        return;
      }

      const button = boardOneButtons.find((b) => b.id.toString() === buttonId);
      if (!button) {
        console.error("Button not found");
        return;
      }

      const updatedUserSequence = [...userSequence, button.id.toString()];
      setUserSequence(updatedUserSequence);

      const currentIndex = updatedUserSequence.length - 1;
      const isCorrect =
        updatedUserSequence[currentIndex] === gameSequence[currentIndex];

      //Show feedback
      playSound(button.sound);
      setActiveButton(button.text);
      setTimeout(() => setActiveButton(null), 400);

      if (!isCorrect) {
        setInputLocked(true);

        setTimeout(() => {
          handleGameOver();
          playSound("/sounds/wrong.mp3"); 
        }, 2000); //update this to reflect the sound playback length

        return;
      }

      //If round complete
      if (updatedUserSequence.length === gameSequence.length) {
        setTimeout(() => {
          setScore((prev) => prev + 1);
          playSound("/sounds/correct.mp3");
        }, 800); //Delay for sound effect
        
        setTimeout(() => {
          setUserSequence([]);
          playSequence();
        }, 1700); // Delay for next sequence
      }
    };

  //#endregion Player Input


  //#region Return TSX

    return (
      <>
        <div className="mimic-mike-home"></div>
          <div className="content-wrapper">
            {gameOver && (
              <GameOverScreen
                score={score}
                highScoreMessage={highScoreMessage} 
                onPlayAgain={handlePlayAgain}
                onQuit={handleQuitGame}
              />
            )}

            {gameStarted ? (
              <div className="game-container">
                <div className="game-header">
                  <h1>Round {round}</h1>
                  <p className="game-score">Score: {score}</p>
                </div>
                {isLoading && 
                  <div className="game-info">
                      <p>Loading...</p>
                  </div>
                }
                <div className="simon-container">
                  {boardOneButtons.map((button) => (
                    <div
                      key={button.id}
                      className={`simon-button simon-${button.text.toLowerCase()} ${
                        activeButton === button.text ? "active" : ""
                      }`}
                      onClick={() => handlePlayerInput(button.id.toString())}
                      style={{
                        pointerEvents: inputLocked ? "none" : "auto",
                      }}
                    >
                        <div className="button-inner">{button.text}</div>
                    </div>
                  ))}
                  <div className="simon-center">
                      <div className="round-display">{round}</div>
                  </div>
                </div>

                <div className="game-controls">
                    <button className="secondary-button" onClick={handleQuitGame}
                    style={{
                        pointerEvents: inputLocked ? "none" : "auto",
                      }}>
                      Quit Game
                    </button>
                </div>
            </div>
          ) : (
            <div className="home-container">
              <div className="title-animation">
                <h1>Mimic Mike</h1>
                <p className="tagline">Test your memory skills!</p>
              </div>

              <div className="game-info">
                <p>
                  Watch and listen to the pattern sequence, then repeat it back in
                  the correct order.
                </p>
                <p>How many rounds can you go?</p>
                <p>Loading...</p>
              </div>
          </div>
          )}
        </div>
      </>
    );

  //#enregion Return TSX

};

export default GameBoard;
